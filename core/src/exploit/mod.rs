/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy
*/
pub mod carbonara;
pub mod kamakiri;
pub mod heapbait;
pub use heapbait::HeapBait;
pub use carbonara::Carbonara;
pub use kamakiri::Kamakiri2 as Kamakiri;

use crate::connection::port::ConnectionType;
use crate::da::protocol::DAProtocol;
use crate::da::{DA, DAEntryRegion};
use crate::error::Result;
const V6_PAYLOAD_MAGIC: &[u8] = b"PENUMBRAV6P";

pub enum BootStage {
    Brom,
    Preloader,
    Da1,
    Da2,
}

pub struct ExploitMeta {
    pub name: String,
    pub boot_mode: Vec<ConnectionType>, // In which mode the exploit works (BROM, Preloader, DA)
    pub boot_stage: BootStage,          /* In which stage the exploit works. (e.g. Kamakiri runs
                                         * in BROM, Carbonara in DA1) */
}

#[async_trait::async_trait]
pub trait Exploit {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool>;

    fn get_meta(&self) -> &ExploitMeta;
    fn get_patched_da(&self) -> Option<DA>;
}

pub fn get_v6_payload(data: &[u8], is_arm64: bool) -> &[u8] {
    if data.len() < 16 + 4 * 4 {
        panic!("Data too short to contain a valid v6 header");
    }

    if &data[0..11] != V6_PAYLOAD_MAGIC {
        panic!("Invalid v6 payload magic");
    }

    // Remove the MAGIC
    let arm7_offset = u32::from_le_bytes(data[16..20].try_into().unwrap()) as usize + 8;
    let arm7_length = u32::from_le_bytes(data[20..24].try_into().unwrap()) as usize - 8;
    let arm64_offset = u32::from_le_bytes(data[24..28].try_into().unwrap()) as usize + 8;
    let arm64_length = u32::from_le_bytes(data[28..32].try_into().unwrap()) as usize - 8;

    if is_arm64 {
        &data[arm64_offset..arm64_offset + arm64_length]
    } else {
        &data[arm7_offset..arm7_offset + arm7_length]
    }
}

pub fn rebuild_patched_da(
    original_da: &DA,
    patched_da1: Option<&DAEntryRegion>,
    patched_da2: Option<&DAEntryRegion>,
) -> DA {
    // We just want to change the region data
    let mut new_regions = Vec::new();

    for region in &original_da.regions {
        if let Some(patched) = patched_da1
            && region.addr == patched.addr
            && region.length == patched.length
        {
            new_regions.push(patched.clone());
            continue;
        }
        if let Some(patched) = patched_da2
            && region.addr == patched.addr
            && region.length == patched.length
        {
            new_regions.push(patched.clone());
            continue;
        }
        new_regions.push(region.clone());
    }

    DA {
        da_type: original_da.da_type.clone(),
        regions: new_regions,
        magic: original_da.magic,
        hw_code: original_da.hw_code,
        hw_sub_code: original_da.hw_sub_code,
    }
}
